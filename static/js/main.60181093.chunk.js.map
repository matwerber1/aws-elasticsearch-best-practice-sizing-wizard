{"version":3,"sources":["logo.svg","App.js","serviceWorker.js","index.js"],"names":["module","exports","WORKLOAD","SINGLE","MULTI","RECOMMENDED_BUFFER","RECOMMENDED_BUFFER_PERCENT","INFLATION_FACTOR","MIN_GB_PER_NODE","MAX_GB_PER_NODE","state","store","indexType","indexSize","indexCount","replicationFactor","clusterStorageGb","storageGbPerIndex","storageGbPerShard","primaryShardCount","dataNodeCount","recommendedDataNodeCounts","useStyles","makeStyles","theme","formControl","margin","spacing","minWidth","selectEmpty","marginTop","root","width","handleStateChange","event","isNaN","target","value","name","parseFloat","updateRecommendedDataNodeCounts","n","small","large","end","Math","floor","sqrt","i","push","reverse","concat","findPrimeFactors","join","ElasticsearchWizard","view","toLocaleString","undefined","maximumFractionDigits","Fragment","CssBaseline","Container","maxWidth","Typography","component","style","backgroundColor","href","StorageCalculator","ShardCalculator","ComputeCalculator","StorageVolumeAdvisor","className","colSpan","getClusterStorage","updateStoragePerIndex","TextField","defaultValue","label","onChange","variant","includes","IndexTypeSelect","IndexCountTextField","DataSizeTextField","ReplicationFactorTextField","StorageRecommendation","StorageTipsAndTricks","classes","FormControl","Select","MenuItem","prompt","App","rel","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.60181093.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","import React, { useState } from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport CssBaseline from '@material-ui/core/CssBaseline';\nimport Typography from '@material-ui/core/Typography';\nimport Container from '@material-ui/core/Container';\nimport { makeStyles } from '@material-ui/core/styles';\nimport InputLabel from '@material-ui/core/InputLabel';\nimport MenuItem from '@material-ui/core/MenuItem';\nimport FormHelperText from '@material-ui/core/FormHelperText';\nimport FormControl from '@material-ui/core/FormControl';\nimport Select from '@material-ui/core/Select';\nimport Slider from '@material-ui/core/Slider';\nimport TextField from '@material-ui/core/TextField';\nimport { store, view } from 'react-easy-state';\nimport Link from '@material-ui/core/Link';\n\n// Global constants / settings for a workload\nconst WORKLOAD = {\n  INDEX_TYPE: {\n    SINGLE: 'singleIndex',\n    MULTI: 'multiIndex'\n  }, \n  STORAGE: {\n    RECOMMENDED_BUFFER: 1.15,\n    RECOMMENDED_BUFFER_PERCENT: 15,\n    INFLATION_FACTOR: 1.1,\n    MIN_GB_PER_NODE: 3,\n    MAX_GB_PER_NODE: 50\n  },\n};\n\n// Global state store w/ react-easy-state:\nconst state = store({\n  indexType: WORKLOAD.INDEX_TYPE.SINGLE,\n  indexSize: 100,\n  indexCount: 1.0,\n  replicationFactor: 2, \n  clusterStorageGb: 0,\n  storageGbPerIndex: 0, \n  storageGbPerShard: 30,\n  primaryShardCount: 0,\n  dataNodeCount: 3,\n  recommendedDataNodeCounts: []\n});\n\n\n//------------------------------------------------------------------------------\n// updatePrimaryShardCount\n//   Based on all of the user's input data, this function calculates a best\n//   practices / rule of thumb number of primary shards recommended for the\n//   cluster (based on the rule of thumb of between 3 to 50 GB storage per shard).\n//------------------------------------------------------------------------------\nconst updatePrimaryShardCount = () => {\n  // We add 0.5 to effectively round up:\n  state.primaryShardCount = ((parseFloat(state.storageGbPerIndex) / parseFloat(state.storageGbPerShard)) + 0.5)\n    .toLocaleString(undefined, { maximumFractionDigits: 0 });\n};\n\nconst useStyles = makeStyles(theme => ({\n  formControl: {\n    margin: theme.spacing(1),\n    minWidth: 120,\n  },\n  selectEmpty: {\n    marginTop: theme.spacing(2),\n  },\n  root: {\n    '& > *': {\n      margin: theme.spacing(1),\n      width: 200,\n    },\n  },\n}));\n\n//------------------------------------------------------------------------------\n// findPrimeFactors\n//  Finds all prime factors of a given number, i.e. all numbers that divide\n//  without a remainder into a target number. This helps us find the recommended\n//  node count that makes se we evenly distribute our shards across nodes. \n//  Code was provided by: \n//  https://js-algorithms.tutorialhorizon.com/2015/09/27/find-all-the-prime-factors-for-the-given-number/\n//------------------------------------------------------------------------------\n\nfunction findPrimeFactors(n) {\n\tif (n < 1)\n\t\tthrow \"Argument error\";\n\tvar small = [];\n\tvar large = [];\n\tvar end = Math.floor(Math.sqrt(n));\n\tfor (var i = 1; i <= end; i++) {\n\t\tif (n % i == 0) {\n\t\t\tsmall.push(i);\n\t\t\tif (i * i != n)  // Don't include a square root twice\n\t\t\t\tlarge.push(n / i);\n\t\t}\n\t}\n\tlarge.reverse();\n\treturn small.concat(large);\n}\n\n//------------------------------------------------------------------------------\n// Helper function that updates state based on the modified field's key. Note\n// that most input fields work fine and pass in an \"event\" object with a\n// target.name and target.value, but certain components like the material-ui\n// Slider do not, and we need a slightly different approach (we use a separate\n// function in these cases:\n//------------------------------------------------------------------------------\nfunction handleStateChange(event) {\n\n  if (isNaN(event.target.value)) {\n    state[event.target.name] = event.target.value;\n  }\n  // If it looks like a number, treat it like a number: \n  else {\n    state[event.target.name] = parseFloat(event.target.value);\n  }\n}\n\n\nconst updateRecommendedDataNodeCounts = () => {\n  state.recommendedDataNodeCounts = findPrimeFactors(state.primaryShardCount).join(\", \");\n}\n\n\n//------------------------------------------------------------------------------\n// ElasticSearchWizard\n//   Main component to render our advice-giving wizard\n//------------------------------------------------------------------------------\nconst ElasticsearchWizard = view(() => {\n  \n  updatePrimaryShardCount();\n  updateRecommendedDataNodeCounts();\n\n  return (\n    <React.Fragment>\n      <CssBaseline />\n      <Container maxWidth=\"md\">\n        <Typography component=\"div\" style={{ backgroundColor: '#cfe8fc' }} >\n        <h1>Amazon Elasticsearch Size Wizard</h1>\n        No surefire method of sizing Amazon ES domains exists, but by starting with an understanding of your storage needs, the service, and Elasticsearch itself, you can make an educated initial estimate on your hardware needs. This estimate can serve as a useful starting point for the most critical aspect of sizing domains: testing them with representative workloads and monitoring their performance.\n        <br/><br/>\n        <a href=\"https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/sizing-domains.html\">Click here</a> for additional info. \n        </Typography>\n      </Container>\n      <br /><br />\n      <b>Note!</b> - This is a work in process. Also, <b>I am fairly new to Elasticsearch</b> (at the time of this writing), so please fact-check any advice you receive here.<br/><br/>\n      <Container maxWidth=\"md\">\n        <Typography component=\"div\" style={{ backgroundColor: '#cfe8fc' }} >\n          <StorageCalculator/>\n        </Typography>\n      </Container>\n      <br/><br/>\n      <Container maxWidth=\"md\">\n        <Typography component=\"div\" style={{ backgroundColor: '#cfe8fc' }} >\n          <ShardCalculator/>\n        </Typography>\n      </Container>\n      <br/><br/>\n      <Container maxWidth=\"md\">\n        <Typography component=\"div\" style={{ backgroundColor: '#cfe8fc' }} >\n          <ComputeCalculator/>\n        </Typography>\n      </Container>\n      <br/><br/>\n      <Container maxWidth=\"md\">\n        <Typography component=\"div\" style={{ backgroundColor: '#cfe8fc' }} >\n          <StorageVolumeAdvisor/>\n        </Typography>\n      </Container>\n    </React.Fragment>\n    \n  );\n});\n\n\n//------------------------------------------------------------------------------\n// VolumeAdvisor\n//   Gives the user recommendations around choosing EBS and/or instance store\n//   volumes. \n//------------------------------------------------------------------------------\nconst StorageVolumeAdvisor = view(() => {\n\n  return (\n    <React.Fragment>\n      <table className=\"MyTable\">\n        <tbody>\n          <tr><td colSpan=\"2\"><h1>Storage Volume Advisor</h1></td></tr>\n          \n          <tr>\n            <td width=\"40%\">\n              <b>Do you need provisioned IOPS (PIOPS) on an EBS volume?</b>\n            </td>\n            <td>\n              Generally, no. ES is not typically IO-intensive. EBS' general purpose SSD <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-volume-types.html\">GP2 volume type</a> gives you 3 IOPS for every 1 GB in storage volume size, up to 3,000 IOPS in total. Often, we find this is enough, and in many cases its more cost-effective to oversize your EBS volume to get extra IOPS than it is to pay for provisioned IOPS.\n              <br />\n              <a href=\"https://youtu.be/95kQkS51VnU?t=1422\">Click here for reference.</a>\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <b>Should you use EBS volumes or instance-store (locally attached) volumes, such as the <a href=\"https://aws.amazon.com/ec2/instance-types/i3/\"></a>EC2 I3<a/> instance:</b>\n            </td>\n            <td>\n              Rather than network-attached EBS volumes, you could optionally use an EC2 instance that have <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html\">NVMe-attached instance storage</a>, which is a high-performance storage volume physically on the same host. I3's can deliver significantly more IOPS (<a href=\"https://aws.amazon.com/about-aws/whats-new/2017/02/now-available-amazon-ec2-i3-instances-next-generation-storage-optimized-high-i-o-instances/\">e.g. up to 3.3M random IOPS at 4KB block size</a>) without any additional storage cost above the price of the EC2 instance itself.\n              <br/><br/>\n              So, should you use an EC2 with instance storeage or an EBS volume? It depends - for smaller use cases (<a href=\"https://youtu.be/95kQkS51VnU\">ballpark, under 5 TB</a>), EC2 with EBS will work and is more cost-effective than instance storage. As your use case grows, there is an inflection point where the I3 storage will be lower-cost.\n              <br /><br />\n              Of course, you may have high performance requirements where, regardless of data size, I3's are needed to meet your throughput requirements and are the better option than EBS.\n              <br/><br />\n              <a href=\"https://youtu.be/95kQkS51VnU?t=1317\">Click here for reference.</a> Note - this reference material refers to I3 vs. R4 and M4 EC2s. Today, we have fifth generation (M5, R5) instances that are higher performance at a lower cost than the old gen-4 instances... so, the breakeven / cost numbers have changed a bit. \n            </td>\n          </tr>\n        </tbody>\n      </table>\n    </React.Fragment>\n  );\n});\n\n//------------------------------------------------------------------------------\n// ShardCalculator\n//   This allows the user to enter information about their workload and receive\n//   a recommendation on the number of shards to use: \n//------------------------------------------------------------------------------\nconst ShardCalculator = view(() => {\n\n  return (\n    <React.Fragment>\n      <table className=\"MyTable\">\n        <tbody>\n          <tr><td colSpan=\"2\"><h1>Shard Count Calculator</h1></td></tr>\n          <tr>\n            <td>\n              <b>Total storage requirement </b>(per above):\n            </td>\n            <td>\n              {getClusterStorage()}\n            </td>\n          </tr>\n         \n          <tr>\n            <td>\n              <b>Number of indexes:</b>\n            </td>\n            <td>\n              {state.indexCount} index{state.indexCount > 1 ? 'es' : ''}\n            </td>\n          </tr>\n         \n          <tr>\n            <td>\n              <b>Storage per Index:</b>\n            </td>\n            <td>\n              {updateStoragePerIndex()} GB per index\n            </td>\n          </tr>\n\n          <tr>\n            <td>\n              <b>Recommended storage per shard:</b>\n            </td>\n            <td>\n              10 to 50 GB per shard.<br />\n              30 GB per shard is a good rule of thumb that we will use below.\n            </td>\n          </tr>\n          \n          <tr>\n            <td>\n              <b>GB per shard for our calculation:</b>\n            </td>\n            <td>\n              {state.storageGbPerShard} GB\n            </td>\n          </tr>\n          \n          <tr>\n            <td>\n              <b>Recommended number of primary shards</b>: \n            </td>\n            <td>\n              <b>{state.primaryShardCount} primary shards</b> (rounded up)\n            </td>\n          </tr>\n          \n          <tr>\n            <td>\n\n            </td>\n            <td>\n              \n            </td>\n          </tr>\n          <tr>\n            <td>\n\n            </td>\n            <td>\n              \n            </td>\n          </tr>\n        </tbody>\n      </table>\n    </React.Fragment>\n  );\n});\n\nconst storagePerShardSliderMarks = [\n  {\n    value: 3,\n    label: '3 GB',\n  },\n  {\n    value: 50,\n    label: '50 GB',\n  },\n];\n\nfunction storagePerShardSliderText(value) {\n  return `${value} GB`;\n}\n\n\n//------------------------------------------------------------------------------\n// ComputeCalculator\n//   This allows the user to enter information about their workload and receive\n//   a recommendation on their compute (vCPU and RAM) needs:\n//------------------------------------------------------------------------------\nconst ComputeCalculator = view(() => {\n\n  // Ratio of CPU to shard should be < 1. Each shard requires a CPU, but we also\n  // need CPU for administrative / background cluster tasks.\n  // https://youtu.be/95kQkS51VnU?t=1157\n\n  // Total shards should be less than 25 / GB of JVM.\n  // https://youtu.be/95kQkS51VnU?t=1196\n\n  // Less than 1000 shards = typically ok \n  // < 10,000 = yellow area\n  // 20,000+ shards = typically problematic\n  // https://youtu.be/95kQkS51VnU?t=1204\n\n  // Max of 50 GB of data per shard: \n  // https://youtu.be/95kQkS51VnU?t=1291\n  \n  // At least a few GBs to \"10s of GBs\", so let's say >= 3GB but, again, less\n  // than 50 GB:\n  // https://www.elastic.co/blog/how-many-shards-should-i-have-in-my-elasticsearch-cluster\n\n  return (\n    <React.Fragment>\n      <table className=\"MyTable\">\n        <tbody>\n          <tr><td width=\"40%\" colSpan=\"2\"><h1>Compute Calculator</h1></td></tr>\n          <tr>\n            <td colSpan=\"2\">\n              <h2>Master nodes</h2>\n            </td>\n          </tr>\n          <tr>\n            <td colSpan=\"2\">\n              <h2>Data nodes</h2>\n            </td>\n          </tr>\n          <tr>\n            <td>\n              Based on your recommended <b>{state.primaryShardCount} primary shards</b> (above), any of the following number of data nodes would give you even shard distribution across your cluster: \n            </td>\n            <td>\n              {state.recommendedDataNodeCounts}\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <b>How many EC2 data nodes do you want?</b>\n              <br /><br/>\n              Fewer nodes are more performant, but we recommend at least two for production to avoid data loss in event of a node failure.\n            </td>\n            <td>\n              <TextField\n                defaultValue={state.dataNodeCount}\n                label=\"Number of data nodes?\"\n                name=\"dataNodeCount\"\n                onChange={handleStateChange} \n                variant=\"filled\"\n              />\n              <br/>\n              {!state.recommendedDataNodeCounts.includes(state.dataNodeCount)\n                ? <p>Warning! {`${state.primaryShardCount} primary shards cannot be evenly distributed across ${state.dataNodeCount} data node(s), which is less than ideal. While it will work, it might lead to hot nodes.`}</p>\n                : \"\"\n              }\n              {state.dataNodeCount < 2\n              ? <p>{`Warning! At least 2 nodes are recommended for production use cases to avoid data loss in the event of node failure.`}</p>\n                : \"\"\n              }\n              {\n                state.dataNodeCount > state.primaryShardCount\n                  ? <p>\"Warning! having more nodes than primary shards means that you will have underutilized nodes. We recommend having as many or fewer nodes than primary shards.\" </p>\n                  : \"\"\n              }\n            </td>\n          </tr>\n          <tr>\n            <td>\n\n            </td>\n            <td>\n              \n            </td>\n          </tr>\n          <tr>\n            <td>\n\n            </td>\n            <td>\n              \n            </td>\n          </tr>\n          <tr>\n            <td>\n\n            </td>\n            <td>\n              \n            </td>\n          </tr>\n          <tr>\n            <td colSpan=\"2\">\n              <b>Tips and tricks: </b>\n              <ul>\n                <li><a href=\"https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/aes-bp.html\">Use three dedicated master nodes spread across three AZs</a></li>\n                <li><a href=\"https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-managedomains-dedicatedmasternodes.html\">AWS master node sizing recommendations</a></li>\n                <li><a href=\"https://www.bluematador.com/docs/troubleshooting/aws-elasticsearch-jvm-pressure\">Nodes allocate 50% of memory to ES JVM, up to 32 GB.</a> Even though nodes with > 64 GB do not increase the JVM Heap, that extra memory can still help related OS tasks and ultimately boost performance. As always, it depends. </li> \n                <li><a href=\"https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/sizing-domains.html#aes-bp-instances\">Low workloads or shard counts, start with 2 vCPUs & 8 GB RAM per 512 GB of storage per node.</a></li>\n                <li><a href=\"https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/sizing-domains.html#aes-bp-instances\">High workloads or shard counts, start with 2 vCPUs & 8 GB RAM per 100 GB of storage per node.</a></li>\n              </ul>\n            </td>\n          </tr>\n        </tbody>\n      </table>\n    </React.Fragment>\n  );\n\n});\n\n\n\n\n//------------------------------------------------------------------------------\n// StorageCalculator\n//   This allows the user to enter information about their indexes and then\n//   provides the user with a recommended cluster storage size in GB.\n//------------------------------------------------------------------------------\nconst StorageCalculator = view(() => {\n  return (\n    <React.Fragment>\n      <table className=\"MyTable\">\n        <tbody>\n          <tr><td colSpan=\"2\"><h1>Storage Calculator</h1></td></tr>\n          <IndexTypeSelect />\n          <IndexCountTextField />\n          <DataSizeTextField />\n          <ReplicationFactorTextField />\n          <StorageRecommendation />\n          <StorageTipsAndTricks />\n        </tbody>\n      </table>\n    </React.Fragment>\n  );\n});\n\n\n//------------------------------------------------------------------------------\n// IndexTypeSelect\n//   Allow the user to select between a single index and a partitioned index. \n//   A common partitioned index would be to have one index per day for logs, \n//   keeping up to X number of days. A \"single index\" means just that - a single\n//   index that we update as needed, such as an item catalog. \n//------------------------------------------------------------------------------\nconst IndexTypeSelect = view(() => {\n\n  const classes = useStyles();\n\n  return (\n    <React.Fragment>\n      <tr>\n        <td width=\"40%\">\n          <b>Will you use a single index, or partition it?</b><br /><br />\n          Typically, we see partioning with streaming use cases, such as log analytics, where you keep X number of days of data, each day gets its own index, and searches are more likely to occur on recent data.\n          <br/><br/>\n          In contrast, a single index might be something like a product catalog, where searches could be at any point in the index. \n        </td>\n        <td>\n          <FormControl className={classes.formControl} variant=\"filled\">\n            <Select\n              name=\"indexType\"\n              value={state.indexType}\n              onChange={handleStateChange}\n            >\n              <MenuItem value={WORKLOAD.INDEX_TYPE.MULTI}>Partitioned index</MenuItem>\n              <MenuItem value={WORKLOAD.INDEX_TYPE.SINGLE}>Single index</MenuItem>\n            </Select>\n          </FormControl>\n        </td>\n      </tr>\n    </React.Fragment>\n  );\n});\n\n\n//------------------------------------------------------------------------------\n// DataSizeTextField\n//   Allows the user to tell us how much data is stored per index. In a single\n//   index use case, this is the entire data set (e.g. 10 GB of product data), \n//   and in a partitioned index use case, this means how much data per index...\n//   for example, if we have one index per day of logs, and each day's logs are\n//   about 10 GB, we would use a value of 10. \n//------------------------------------------------------------------------------\nconst DataSizeTextField = view(() => {\n  var prompt;\n  if (state.indexType === WORKLOAD.INDEX_TYPE.SINGLE) {\n    prompt = 'How much data will your index hold?';\n  }\n  else {\n    prompt = 'How much data will each index hold?';\n  }\n  return (\n    <React.Fragment>\n      <tr>\n        <td>\n          <b>{prompt}</b>\n        </td>\n        <td>\n          <TextField\n            defaultValue={state.indexSize}\n            label=\"data size in GB?\"\n            name=\"indexSize\"\n            onChange={handleStateChange} \n            variant=\"filled\"\n            />\n        </td>\n      </tr>\n    </React.Fragment>\n  )\n});\n\n\n//------------------------------------------------------------------------------\n// IndexCountTextField\n//   Allows user to specify how many partitions will be kept in the cluster for\n//   a partitioned index (not applicable to single index). For example, if the\n//   customer has 10 GB of log data per day and wants to keep 30 days of log data\n//   in their cluster, they would have one index per day and the value of this\n//   field would be 30. \n//------------------------------------------------------------------------------\nconst IndexCountTextField = view(() => {\n    \n  if (state.indexType === WORKLOAD.INDEX_TYPE.MULTI) {\n    return (\n      <React.Fragment>\n        <tr>\n          <td>\n            <b>How many index partitions will you keep?</b>\n          </td>\n          <td>\n            <TextField\n              defaultValue={state.indexCount}\n              label=\"Number of partitions?\"\n              name=\"indexCount\"\n              onChange={handleStateChange} \n              variant=\"filled\"\n            />\n          </td>\n        </tr>\n      </React.Fragment>\n    )\n  }\n  else {\n    state.indexCount = 1;\n    return;\n  }\n});\n\n\n//------------------------------------------------------------------------------\n// getClusterStorage\n//   Based on all of the user's input data, this function calculates a best\n//   practices / rule of thumb storage requirement in GB for their ES cluster. \n//   Actual requirements may vary. It updates the state and also returns the\n//   the new value to the function caller.\n//------------------------------------------------------------------------------\nconst getClusterStorage = () => {\n\n  state.clusterStorageGb =\n    state.indexSize\n    * state.replicationFactor\n    * state.indexCount\n    * WORKLOAD.STORAGE.RECOMMENDED_BUFFER\n    * WORKLOAD.STORAGE.INFLATION_FACTOR\n    ;\n  \n    if (state.clusterStorageGb < 1000) {\n      return state.clusterStorageGb.toLocaleString(undefined, { maximumFractionDigits: 0 }) + \" GB\";\n    }\n    else if (state.clusterStorageGb < 1000000) {\n      // Round up to nearest 100 GB:\n      return ((state.clusterStorageGb + 100) / 1000).toLocaleString(undefined, { maximumFractionDigits: 1 }) + \" TB\";\n    }\n    else {\n      // Round up to nearest 1 TB:\n      return ((state.clusterStorageGb + 1000) / 1000000).toLocaleString(undefined, { maximumFractionDigits: 3 }) + \" PB\";\n    }      \n};\n\n\n//------------------------------------------------------------------------------\n// updateStoragePerIndex\n//------------------------------------------------------------------------------\nconst updateStoragePerIndex = () => {\n  state.storageGbPerIndex =  state.clusterStorageGb / state.indexCount;\n  return state.storageGbPerIndex.toLocaleString(undefined, { maximumFractionDigits: 1 });\n}\n\n//------------------------------------------------------------------------------\n// round\n//   Numbers need to be rounded, yo. \n//------------------------------------------------------------------------------\nfunction round(n, precision) {\n  if (precision < 0) {\n    const length = String(n).split('.')[0].length;\n    return parseFloat(n.toLocaleString('en', { maximumSignificantDigits: length + precision, useGrouping: false }));\n  }\n  return parseFloat(n.toLocaleString('en', { maximumFractionDigits: precision, useGrouping: false }));\n}\n\n//------------------------------------------------------------------------------\n// ReplicationFactorTextField\n//   Allows the user to specify their replication factor. A value of 1 indicates\n//   only primary shards with no replica, a value of 2 means one primary and\n//   one replica, so on and so forth. For production, we recommend at least a\n//   replication of factor of 2 so that a node failure does not lead to data loss.\n//------------------------------------------------------------------------------\nconst ReplicationFactorTextField = view(() => {\n  return (\n    <React.Fragment>\n      <tr>\n        <td>\n          <b>What is your replication factor?</b><br />\n        </td>\n        <td>\n          <TextField\n            defaultValue={state.replicationFactor}\n            label=\"replication factor?\"\n            name=\"replicationFactor\"\n            onChange={handleStateChange} \n            variant=\"filled\"\n          />\n          <br /><br/>\n          <li>Best practice - <a href=\"https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/aes-bp.html\">at least 1 replica</a> (replication factor = 2)</li>\n        </td>\n      </tr>\n    </React.Fragment>\n  );\n});\n\n\n//------------------------------------------------------------------------------\n// StorageRecommendation\n//   This component renders a box to display recommended storage to the user\n//   based on their form input. \n//------------------------------------------------------------------------------\nconst StorageRecommendation = view(() => {\n\n  function PetabyteDisclaimer() {\n    return (\n      <React.Fragment>\n        <br/><br/>\n        <b>Important!</b> - As your storage requirements are >= 1 PB, you should instead follow the recommendations <a href=\"https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/petabyte-scale.html\">in this guide</a>.\n      </React.Fragment>\n    );\n  }\n\n  return (\n    <React.Fragment>\n      <tr>\n        <td>\n          <b>Recommended storage:</b><br/>\n          <a href=\"https://youtu.be/95kQkS51VnU?t=589\" >Based on this guidance</a>\n          <br /><br />\n          Note that <a href=\"https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/sizing-domains.html\">these AWS docs</a> call for a slightly different formula, but the results are more or less the same. \n        </td>\n        <td>\n          = {state.indexSize} GB storage * {WORKLOAD.STORAGE.INFLATION_FACTOR} inflation factor * {state.replicationFactor} replication factor  * {state.indexCount} index partitions * {WORKLOAD.STORAGE.RECOMMENDED_BUFFER} buffer factor\n          <br/>\n          = <b>{getClusterStorage()}</b> recommended cluster storage.\n          {state.clusterStorageGb > 1000000 ? <PetabyteDisclaimer /> : \"\"}\n        </td>\n      </tr>\n    </React.Fragment>\n  );\n});\n\n\n//------------------------------------------------------------------------------\n// StorageTipsAndTricks\n//   Provides users with links to further best practices. \n//------------------------------------------------------------------------------\nconst StorageTipsAndTricks = view(() => {\n\n  return (\n    <React.Fragment>\n      <tr>\n        <td colSpan=\"2\">\n          <b>Storage tips and tricks: </b><br />\n          <br />\n          <ul>\n            <li><a href=\"https://youtu.be/95kQkS51VnU?t=650\">Reducing source data has the greatest impact on storage needs</a></li>\n              <ul>\n                <li>for example, <a href=\"https://youtu.be/95kQkS51VnU?t=730\">removing @message</a> has a huge impact</li>\n              </ul>\n            <li><a href=\"https://youtu.be/95kQkS51VnU?t=817\">Disable uneeded mapping features</a></li>\n          </ul>\n        </td>\n      </tr>\n    </React.Fragment>\n  );\n});\n\n\n//------------------------------------------------------------------------------\n// App\n//   Main entry point into our application.\n//------------------------------------------------------------------------------\nconst App = view(() => {\n  return (\n    <div className=\"App\">\n      <header>\n        <link rel=\"stylesheet\" href=\"https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap\" />\n      </header>\n      <ElasticsearchWizard />\n      <br />\n      <br />\n      <br />\n      <br/>\n      <br/>\n      <br/>\n      <br/>\n      <br/>\n    </div>\n  );\n});\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}